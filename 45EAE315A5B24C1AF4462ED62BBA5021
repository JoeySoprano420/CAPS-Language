# CAPS-Language
Computational Algorithmic Programming Sequence Language

---

## 1. What CAPS Does **So Far** (With the Upgrade Included)

### At its core, CAPS is:

> **A deterministic, analyzable, state-machine language for orchestrating communicating processes with compile-time guarantees.**

That’s not marketing—that’s literally what your compiler enforces.

### CAPS currently models **four things extremely well**

---

### 1️⃣ Clean, Deterministic Type System

CAPS features a powerful type system ensuring safety and determinism:

- **Generics**: Parameterized types (`Vec<T>`)
- **Dependent Types**: Types depending on values (`{int | x > 0}`)
- **Refinement Types**: Subtypes with predicates
- **Union Types**: Sum types for variants
- **Enum/Struct**: Algebraic data types
- **Ownership & Borrowing**: Automatic memory management
- **Type Inference**: Automatic type deduction
- **Deterministic Types**: No non-deterministic constructs

**Benefits:**
- **Safety**: Compile-time prevention of type errors
- **Expressiveness**: Rich types for complex data
- **Performance**: Optimized representations

---

### 2️⃣ Strong Static Analysis

CAPS provides comprehensive static analysis:

- **Type Safety Proofs**: Prove absence of type errors
- **Lifetime Analysis**: Ensure no dangling references
- **Borrow Checking**: Ownership and borrowing rules
- **Resource Bounds**: Prove memory and CPU limits
- **Concurrency Verification**: Safe parallel execution
- **Determinism Checks**: Verify predictable behavior
- **Deadlock Detection**: Find potential deadlocks
- **Liveness Verification**: Ensure progress

**Tools:**
- `--analyze-lifetimes`
- `--borrow-check`
- `--prove-resources`

---

### 3️⃣ Massive Powerful Stdlib

CAPS includes a comprehensive standard library:

- **Core**: Option, Result, Vec, Map, String
- **Math**: Trigonometry, algebra, constants
- **Concurrency**: Sync primitives, channels, timers
- **I/O**: File, console, networking
- **Utils**: Iterators, formatting, testing
- **Deterministic**: All operations are predictable

**Usage:**
```
import std.vec;
import std.math;

let v = Vec::new();
v.push(42);
let s = math::sin(math::PI);
```

---

### 4️⃣ Good Tooling

CAPS offers excellent development tools:

- **Formatter**: Customizable code formatting
- **Linter**: Rule-based style and error checking
- **Package Manager**: Dependency and version management
- **Debugger**: Interactive debugging
- **LSP**: Full IDE integration
- **Build System**: Advanced compilation

**Integration:** Seamless with VSCode, Vim, etc.

---

### 4.1 Pipeline Stages

1. **Lexing/Parsing**: Tokenize → AST (recursive descent parser).
2. **Name Resolution**: Build symbol tables (modules, groups, processes, channels).
3. **Type Checking**: Infer/check types; enforce channel/process scoping.
4. **Well-Formedness**: Validate FSMs, transitions, annotations.
5. **Annotation Enforcement**: Topology graphs, cycle detection, schedule validation.
6. **Static Analysis**: Liveness, reachability, resource bounds, data flow, timer determinism, I/O safety, deadlock detection, memory proofs, lifecycle verification, determinism proofs.
7. **Compile-Time Proofs**: Automated theorem proving, model checking, timer/I/O proofs, advanced invariants.
8. **Optimizations**: Dead code elimination, channel fusion, process inlining, static memory layout, zero-copy message passing.
9. **IR Lowering**: AST → Typed IR (desugar `?`, normalize transitions, handle FFI).
10. **Optimizations**: Dead code elimination, channel fusion, process inlining, static memory layout, zero-copy message passing.
11. **Backend Selection**: Typed IR → C++ (AOT) or x86-64 (direct).
12. **Codegen**: Emit .cpp/.exe or .asm/.obj with unwind/debug info, including FFI calls.
13. **Linking**: MSVC/lld-link to PE .exe, resolving FFI symbols.

**Compile-Time Guarantees in Pipeline:**
Each stage enforces CAPS's guarantees: parsing ensures total transitions, sema validates types and topology, static analysis proves properties like deadlock freedom and bounded memory, IR lowering desugars error handling and FFI. No shared memory assumptions; ownership is tracked implicitly. Advanced proofs ensure lifecycle and determinism.

---

## 2. New In This Upgrade

### Overview

This upgrade expands CAPS's syntax and capabilities significantly. Key additions are:

- **Pattern Matching**: Match expressions against patterns.
- **Static Arrays**: Fixed-size arrays known at compile-time.
- **Deterministic Loops**: Loops with compile-time known bounds.
- **Compile-Time Functions**: Functions evaluated at compile-time.
- **New Type System Features**: Generics, unions, structs, enums, refinements, dependents.
- **Additional Statements and Expressions**: New syntax for improved expressiveness.

### Gory Details

#### Channels
- Declaration: `channel<T; N> name`, `priority_channel<T; N>`, `timeout_channel<T; N; timeout>`
- Operations: `send expr -> chan`, `receive chan -> var`, `try_send`, `try_receive`
- Semantics: Bounded queues, priorities, timeouts

#### Processes
- Signature: `process Name(inputs) -> (outputs) { ... }`
- States: Declared explicitly (e.g., `state Start, Send`)
- Locals: `var/let name:T = expr`
- On-blocks: `on State { actions; transition }`
- Transitions: `-> State` or `if cond { then_actions; -> ThenState } else { else_actions; -> ElseState }`
- **Enhanced**: `mutex`, `atomic { ... }`, nested states

#### Expressions
- Literals: `int`, `real`, `text`, `bool`
- Operators: Arithmetic (`+`, `-`, `*`, `/`), comparisons (`==`, `!=`, `<`, etc.), logical (`&&`, `||`)
- Calls: `len(channel)`, `get_deterministic_timer()`, `write_deterministic_io(data)`, `static_sin(x)`, etc.
- Result handling: `expr?` for error propagation (desugars to `__Error` state)
- **Match**: `match expr { pattern => action }`
- **Arrays**: `[elem1, elem2]`
- **Loops**: `for var in start..end { ... }`

#### Types
- Primitives: `int`, `bool`, `real`, `text`
- Composites: `Result<T, E>` (e.g., `Result<int, text>` for try ops)
- Channels: `channel<T; N>`, `priority_channel<T; N>`, `timeout_channel<T; N; timeout>`
- **Generics**: `List<T>`, `Option<T>`
- **Unions**: `union { int, text }`
- **Structs**: `struct Point { x:int, y:int }`
- **Enums**: `enum Color { Red, Green, Blue }`
- **Refinements**: `{int | x > 0}` (positive integers)
- **Dependents**: Arrays sized by values (e.g., `array<int; n>` where `n` is constant)
- **Fixed-Size Buffers**: `buffer<T; N>` for compile-time sized arrays
- **Bounded Queues**: Channels as `queue<T; N>`
- **Static Arrays**: `[T; N]` for immutable fixed-size arrays
- **Collections**: `stack<T; N>`, `queue<T; N>`, `map<K, V; N>`
- **Stdlib Types**: `Vec<T>`, `Map<K, V>`, `Option<T>`

#### Imports
- **Modules**: `import std.vec;`
- **Selective**: `import std.math::{sin, cos};`

#### Stdlib Functions
- **Vec**: `new()`, `push()`, `len()`
- **Math**: `sin()`, `cos()`, `sqrt()`
- **Option**: `is_some()`, `unwrap()`
- **I/O**: `println()`, `read_line()`

---

### 🔟 More Optimizations

Advanced passes for performance:

- **Constant Folding**: Evaluate expressions at compile-time.
- **Inlining**: Embed small functions for speed.
- **Dead Code Elimination**: Remove unused states/channels.
- **Channel Fusion**: Merge compatible channels.
- **Buffer Optimization**: Optimize fixed-size buffers.
- **Math Utilities**: Static math computations.
- **Process Inlining**: Inline small processes.
- **Static Memory Layout**: Pre-allocate memory.
- **Zero-Copy Message Passing**: Pass messages without copying.
- **Deterministic Register Allocation**: Predictable register assignment.
- **Architecture-Specific Instruction Selection**: Optimized for target arch.
- **Static Scheduling**: Deterministic instruction ordering.
- **Whole-Program Optimization**: Global analysis and optimization.
- **Zero-Copy Channel Lowering**: Efficient channel operations.
- **Deterministic Inlining**: Predictable function inlining.
- **Custom IR Passes**: Extensible optimization pipeline.

**Flags:**
- `--optimize-aggressive`: Enable all passes.
- `--profile-guided`: Use profiling for optimization.
- `--enable-zero-copy`: Enable zero-copy messaging.
- `--static-memory`: Use static memory layout.
- `--target-arch=x86_64|arm64|riscv|wasm`: Select target architecture.

---

### 1️⃣1️⃣ Multi-Architecture Support

CAPS supports multiple architectures:

- **x86_64**: Full backend with deterministic allocator and instruction selection.
- **ARM64**: AArch64 support for mobile and embedded.
- **RISC-V**: Open-source ISA for custom hardware.
- **WASM**: WebAssembly for web deployment.

**Platforms:**
- Linux, macOS, Windows
- Embedded targets (bare metal)
- Web (via WASM)

---

### 1️⃣2️⃣ Comprehensive Ecosystem

CAPS ships with a full ecosystem:

- **Stdlib**: Core, math, crypto, drivers, orchestration, allocators, FFI, I/O, networking.
- **Tools**: Formatter, linter, debugger, LSP, package manager, build system.
- **Tests**: Unit, integration, regression, conformance, backend, stdlib tests.
- **Documentation**: Tutorials, examples, docs, blog, samples, use-cases, benchmarks, community.

**Deterministic I/O**: Bounded, predictable operations.
**Fixed-Size Collections**: Arrays, stacks, queues, maps.
**Math Libraries**: Trigonometry, algebra, constants.
**Crypto**: Hashing, encryption.
**Embedded Drivers**: GPIO, UART, etc.
**Concurrency Orchestration**: Process management.
**Static Allocators**: Compile-time memory management.
**Safe FFI Layers**: Type-safe C interop.
**Deterministic File/Network APIs**: Predictable I/O.

---

### 🔟 More Tools

CAPS now includes a full suite of development tools:

- **Formatter (`caps_formatter`)**: Formats code with customizable rules, alignment, import sorting.
- **Linter (`caps_linter`)**: Advanced linting with rules, severity, suggestions, auto-fix.
- **Package Manager (`caps_pm`)**: Manages packages with dependencies, versions, registry.
- **Debugger (`caps_debugger`)**: Interactive debugging with breakpoints and inspection.
- **Language Server (`caps_lsp`)**: Full LSP for IDE integration with completion, hover, diagnostics.
- **Build System (`caps_build`)**: Custom build tool with dependency resolution.
- **Profiler (`caps_profiler`)**: Profiles execution time, throughput, memory.
- **Documentation Generator (`caps_docgen`)**: Generates HTML docs from source.
- **Static Analyzer (`caps_analyzer`)**: Advanced data/control flow analysis.
- **Deterministic Performance Tools (`caps_perf`)**: Measures worst-case execution, benchmarks.

**Usage Examples:**
- Format: `caps_formatter file.caps --indent=4 --align`
- Lint: `caps_linter file.caps --fix`
- Package: `caps_pm install stdlib 1.0.0`
- Debug: `caps_debugger file.caps`
- LSP: Run as server for editors
- Build: `caps_build .`
- Profile: `caps_profiler file.caps`
- Docs: `caps_docgen src/ --output=docs/`
- Analyze: `caps_analyzer file.caps`
- Perf: `caps_perf file.caps`

---

### 1️⃣1️⃣ Advanced Backend Features

CAPS backends include:

- **Deterministic Register Allocator**: Predictable allocation.
- **Architecture-Specific Instruction Selection**: Optimized for x86_64, ARM64, RISC-V, WASM.
- **Static Scheduling**: Deterministic instruction ordering.
- **Whole-Program Optimization**: Global analysis.
- **Zero-Copy Channel Lowering**: Efficient messaging.
- **Deterministic Inlining**: Predictable expansion.
- **Custom IR Passes**: Extensible optimization.
- **Whole-Program Analysis Baked into Codegen**: Global insights in emission.
- **Deterministic Process Scheduling**: Predictable execution order.
- **Static Memory Layout**: Pre-allocated memory.
- **Channel Graph Lowering**: Optimized graphs.
- **Zero-Copy Message Passing**: Reference passing.
- **Fixed-Time Code Generation**: Bounded compilation.
- **Predictable Branching**: Optimized prediction.
- **Deterministic Inlining**: Consistent inlining.
- **Static Stack Frame Construction**: Pre-built frames.

---

### 1️⃣2️⃣ Comprehensive Ecosystem

CAPS ships with a full ecosystem:

- **Stdlib**: Core, math, crypto, drivers, orchestration, allocators, FFI, I/O, networking, random.
- **Tools**: Full suite as above.
- **Tests**: Unit, integration, regression, conformance, backend, stdlib.
- **Documentation**: Tutorials, examples, docs, blog, samples, use-cases, benchmarks, community.
- **OS Kernel**: Deterministic kernel with scheduling, memory, I/O, networking.
- **VM**: Deterministic bytecode VM.
- **Distributed Runtime**: Deterministic distributed execution.
- **Embedded/Cloud Runtimes**: Specialized runtimes.
- **Package Ecosystem**: Registry and management.
- **Deterministic Debugger/Profiler/Build**: Specialized tools.

**Deterministic I/O**: Bounded, predictable.
**Fixed-Size Collections**: Arrays, stacks, queues, maps.
**Math Libraries**: Trigonometry, algebra, constants, random.
**Crypto**: Hashing, encryption.
**Embedded Drivers**: GPIO, UART.
**Concurrency Orchestration**: Process management.
**Static Allocators**: Memory management.
**Safe FFI Layers**: C interop.
**Deterministic File/Network APIs**: Predictable ops.

---

### 1️⃣3️⃣ Comprehensive Test Suites

CAPS includes extensive test suites:

- **Unit Tests**: Individual component testing.
- **Integration Tests**: Component interaction verification.
- **Regression Tests**: Prevent regressions.
- **Conformance Suites**: Language compliance checks.
- **Backend Tests**: Code generation validation.
- **Stdlib Tests**: Standard library testing.
- **Deadlock Conformance Tests**: Deadlock detection verification.
- **Channel Graph Tests**: Communication graph analysis.
- **Determinism Tests**: Deterministic behavior validation.
- **Platform Tests**: Cross-platform compatibility.
- **Fuzzing Harnesses**: Automated bug finding.
- **Formal Verification Artifacts**: Models and proofs.

**Run Tests**: `ctest` or individual executables.







