#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <cstdlib>

#include "util/str.h"
#include "util/diag.h"
#include "lexer/lexer.h"
#include "parser/parser.h"
#include "sema/sema.h"
#include "ir/lowering.h"
#include "ir/typed_lowering.h"
#include "x64/x64_codegen.h"
#include "aot/aot_codegen.h"
#include "pretty/pretty.h"
#include "pretty/ast_dump.h"
#include "analysis/pipeline.h"

static bool has_ann(const std::vector<Annotation>& anns, const std::string& n) {
  for (auto& a : anns) if (a.name == n) return true;
  return false;
}


enum class TopologyFormat { None, Dot, Text };

struct Options {
  bool dump_ast = false;
  TopologyFormat dump_topology = TopologyFormat::None;
  bool check_only = false;
  std::string input_file;
  std::string output_ir_file;
  std::string emit_cpp_dir;
  bool compile = false;
  std::string emit_obj_file;
  std::string emit_asm_file;
};


static void print_usage() {
  std::cerr <<
    "usage: caps_frontend [--dump-ast] [--dump-topology=dot|text] [--check-only] [--output-ir=<file>] [--emit-cpp=<dir>] [--compile] [--emit-asm=<file>] [--emit-obj=<file>] <file.caps>\n"
    "\n"
    "  --dump-ast             Print parsed+sema-mutated AST\n"
    "  --dump-topology=dot    Print @pipeline_safe topology as Graphviz DOT\n"
    "  --dump-topology=text   Print @pipeline_safe topology as human-readable text\n"
    "  --check-only           CI mode: diagnostics only; exit 0 on success, 2 on any error\n"
    "  --output-ir=<file>     Write IR output to file instead of stdout\n"
    "  --emit-cpp=<dir>       Emit C++ code for each group to <dir>/<group>.cpp\n"
    "  --compile              Compile the emitted C++ to .exe using MSVC\n"
    "  --emit-asm=<file>      Emit x86-64 assembly to <file>\n"
    "  --emit-obj=<file>      Emit COFF .obj file to <file>\n";
}


static bool parse_args(int argc, char** argv, Options& opt) {
  for (int i = 1; i < argc; i++) {
    std::string a = argv[i];

    if (a == "--dump-ast") { opt.dump_ast = true; continue; }

    if (a.rfind("--dump-topology", 0) == 0) {
      // Accept: --dump-topology=dot or --dump-topology=text
      auto eq = a.find('=');
      if (eq == std::string::npos) {
        std::cerr << "error: --dump-topology requires '=dot' or '=text'\n";
        return false;
      }
      std::string fmt = a.substr(eq + 1);
      if (fmt == "dot") opt.dump_topology = TopologyFormat::Dot;
      else if (fmt == "text") opt.dump_topology = TopologyFormat::Text;
      else {
        std::cerr << "error: unknown --dump-topology format: " << fmt << "\n";
        return false;
      }
      continue;
    }

    if (a == "--check-only") { opt.check_only = true; continue; }

    if (a.rfind("--output-ir=", 0) == 0) {
      auto eq = a.find('=');
      if (eq == std::string::npos) {
        std::cerr << "error: --output-ir requires '=file'\n";
        return false;
      }
      opt.output_ir_file = a.substr(eq + 1);
      continue;
    }

    if (a.rfind("--emit-cpp=", 0) == 0) {
      auto eq = a.find('=');
      if (eq == std::string::npos) {
        std::cerr << "error: --emit-cpp requires '=dir'\n";
        return false;
      }
      opt.emit_cpp_dir = a.substr(eq + 1);
      continue;
    }

    if (a == "--compile") { opt.compile = true; continue; }

    if (a.rfind("--emit-obj=", 0) == 0) {
      auto eq = a.find('=');
      if (eq == std::string::npos) {
        std::cerr << "error: --emit-obj requires '=file'\n";
        return false;
      }
      opt.emit_obj_file = a.substr(eq + 1);
      continue;
    }

    if (a.rfind("--emit-asm=", 0) == 0) {
      auto eq = a.find('=');
      if (eq == std::string::npos) {
        std::cerr << "error: --emit-asm requires '=file'\n";
        return false;
      }
      opt.emit_asm_file = a.substr(eq + 1);
      continue;
    }

    if (!a.empty() && a[0] == '-') {
      std::cerr << "unknown option: " << a << "\n";
      return false;
    }

    opt.input_file = a;
  }
  return !opt.input_file.empty();
}


int main(int argc, char** argv) {
  Options opt;
  if (!parse_args(argc, argv, opt)) {
    print_usage();
    return 1;
  }

  std::string src;
  try {
    src = read_file_to_string(opt.input_file);
  } catch (const std::exception& e) {
    std::cerr << "read error: " << e.what() << "\n";
    return 1;
  }

  Diag diag;
  Lexer lex(src, diag);
  Parser parser(lex, diag);

  Program prog = parser.parse_program();

  // Sema (also runs pipeline checks)
  Sema sema(diag);
  sema.check(prog);

  if (diag.has_errors()) {
    diag.print_all(std::cerr);
    return 2; // CI-compatible error code
  }

  // In check-only mode: succeed without emitting anything (unless user asked for dumps)
  // (This makes it friendly for CI logs.)
  if (opt.check_only && !opt.dump_ast && !opt.dump_topology) {
    return 0;
  }

  // --dump-ast
  if (opt.dump_ast) {
    dump_ast(std::cout, prog);
    if (!opt.dump_topology) std::cout << "\n";
  }

  // --dump-topology (all @pipeline_safe groups)
  if (opt.dump_topology != TopologyFormat::None) {
    bool printed_any = false;

    for (auto& g : prog.groups) {
      if (!has_ann(g.annotations, "pipeline_safe")) continue;

      printed_any = true;
      auto tg = build_topology_graph(g);

      // Emit ambiguous warnings to stderr
      for (auto& w : tg.ambiguities) {
        std::cerr << "warning: group '" << g.name << "' channel '" << w.channel
                  << "' ambiguous (writers=" << w.writers.size()
                  << ", readers=" << w.readers.size() << ")\n";
      }

      if (opt.dump_topology == TopologyFormat::Dot) {
        dump_topology_dot(std::cout, g, tg);
        std::cout << "\n";
      } else {
        dump_topology_text(std::cout, g, tg);
        std::cout << "\n";
      }
    }

    if (!printed_any) {
      std::cerr << "warning: --dump-topology requested but no @pipeline_safe group found\n";
    }
  }


  // Default output (IR) if not check-only
  if (!opt.check_only) {
    Lowering lower;
    for (auto& g : prog.groups) {
      IRGroup irg = lower.lower_group(g);
      if (!opt.output_ir_file.empty()) {
        std::ofstream ofs(opt.output_ir_file);
        if (!ofs) {
          std::cerr << "error: cannot open output file: " << opt.output_ir_file << "\n";
          return 1;
        }
        print_ir(ofs, irg);
      } else {
        print_ir(std::cout, irg);
      }

      if (!opt.emit_cpp_dir.empty()) {
        caps::aot::Group tg = caps::aot::lower_typed(irg);
        std::string cpp_code = caps::aot::emit_cpp(tg, true);
        std::string cpp_file = opt.emit_cpp_dir + "/" + g.name + ".cpp";
        std::ofstream ofs(cpp_file);
        if (!ofs) {
          std::cerr << "error: cannot open C++ output file: " << cpp_file << "\n";
          return 1;
        }
        ofs << cpp_code;
        std::cout << "Emitted C++ to " << cpp_file << "\n";

        if (opt.compile) {
          std::string exe_file = g.name + ".exe";
          std::string cmd = "cl /std:c++17 /O2 /EHsc " + cpp_file + " /Fe:" + exe_file;
          int ret = system(cmd.c_str());
          if (ret != 0) {
            std::cerr << "Compilation failed for " << g.name << "\n";
            return 1;
          }
          std::cout << "Compiled to " << exe_file << "\n";
        }
      }

      // New: emit .obj or .asm
      if (!opt.emit_obj_file.empty() || !opt.emit_asm_file.empty()) {
        // Implement full x86-64 backend
        caps::x64::X64Module xmod;
        // Build xmod from irg (lower to x64 IR)
        if (!opt.emit_asm_file.empty()) {
          if (!caps::x64::emit_asm(xmod, opt.emit_asm_file)) {
            std::cerr << "Failed to emit ASM\n";
            return 1;
          }
          std::cout << "Emitted ASM to " << opt.emit_asm_file << "\n";
        }
        if (!opt.emit_obj_file.empty()) {
          if (!caps::x64::emit_obj(xmod, opt.emit_obj_file)) {
            std::cerr << "Failed to emit OBJ\n";
            return 1;
          }
          std::cout << "Emitted OBJ to " << opt.emit_obj_file << "\n";
        }
      }
    }
  }

  return 0;
}
