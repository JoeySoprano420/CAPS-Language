#include "aot_codegen.h"
#include <sstream>
#include <cctype>
#include <unordered_set>

namespace caps::aot {

static std::string ident(std::string s) {
  // C++ identifier sanitizer
  for (char& c : s) {
    if (!(std::isalnum((unsigned char)c) || c=='_')) c='_';
  }
  if (s.empty() || std::isdigit((unsigned char)s[0])) s = "_" + s;
  return s;
}

static const char* cpp_type(TypeKind k) {
  switch (k) {
    case TypeKind::I64: return "int64_t";
    case TypeKind::Bool: return "bool";
    case TypeKind::F64: return "double";
    case TypeKind::Text: return "std::string";
    case TypeKind::ResultBoolText: return "Result_bool_text";
    case TypeKind::ResultI64Text: return "Result_i64_text";
    case TypeKind::ResultTextText: return "Result_text_text";
  }
  return "/*unknown*/";
}

static std::string lit_text(const std::string& s) {
  std::ostringstream os;
  os << "\"";
  for (char c : s) {
    if (c == '\\') os << "\\\\";
    else if (c == '"') os << "\\\"";
    else if (c == '\n') os << "\\n";
    else os << c;
  }
  os << "\"";
  return os.str();
}

static void emit_expr(std::ostringstream& o, const Expr& e);

static void emit_binop(std::ostringstream& o, const Expr& e) {
  // assumes typechecked
  if (e.args.size() != 2) throw std::runtime_error("BinOp expects 2 args");
  o << "(";
  emit_expr(o, e.args[0]);
  o << " " << e.op << " ";
  emit_expr(o, e.args[1]);
  o << ")";
}

static void emit_expr(std::ostringstream& o, const Expr& e) {
  using K = Expr::Kind;
  switch (e.kind) {
    case K::LitI64: o << e.i64; return;
    case K::LitBool: o << (e.b ? "true" : "false"); return;
    case K::LitF64: o << e.f64; return;
    case K::LitText: o << lit_text(e.text); return;
    case K::Var: o << ident(e.var); return;
    case K::BinOp: emit_binop(o, e); return;

    case K::ResultOk:
      o << "("; emit_expr(o, e.args.at(0)); o << ").ok";
      return;
    case K::ResultValue:
      o << "("; emit_expr(o, e.args.at(0)); o << ").value";
      return;
    case K::ResultError:
      o << "("; emit_expr(o, e.args.at(0)); o << ").error";
      return;

    case K::Call:
      if (e.func_name == "len") {
        if (e.args.size() != 1) throw std::runtime_error("len expects 1 arg");
        o << "channels." << ident(e.args[0].var) << ".size()";
      } else {
        throw std::runtime_error("unknown function: " + e.func_name);
      }
      return;
  }
  throw std::runtime_error("unknown Expr kind");
}

static void emit_action(std::ostringstream& o, const Action& a, const Group& g) {
  using K = Action::Kind;
  auto dst = ident(a.dst);
  auto ch = ident(a.chan);

  switch (a.kind) {
    case K::Assign: {
      o << "      " << dst << " = ";
      emit_expr(o, a.expr);
      o << ";\n";
      return;
    }
    case K::Send: {
      o << "      if (!channels." << ch << ".send(";
      emit_expr(o, a.expr);
      o << ")) { blocked = true; block_reason = \"send\"; }\n";
      return;
    }
    case K::Receive: {
      o << "      if (!channels." << ch << ".recv(" << dst << ")) { blocked = true; block_reason = \"recv\"; }\n";
      return;
    }
    case K::TrySend: {
      o << "      " << dst << " = channels." << ch << ".try_send(";
      emit_expr(o, a.expr);
      o << ");\n";
      return;
    }
    case K::TryReceive: {
      // returns Result<T,text>
      o << "      " << dst << " = channels." << ch << ".try_recv();\n";
      return;
    }
  }
}

static void emit_action_list(std::ostringstream& o, const std::vector<Action>& acts, const Group& g) {
  for (auto& a : acts) emit_action(o, a, g);
}

static std::vector<std::string> topo_states(const Process& p) {
  // stable emission order: initial first, then others lexicographically
  std::vector<std::string> out;
  out.push_back(p.initial_state);
  std::unordered_set<std::string> seen{p.initial_state};
  std::vector<std::string> rest;
  for (auto& kv : p.states) {
    if (!seen.count(kv.first)) rest.push_back(kv.first);
  }
  std::sort(rest.begin(), rest.end());
  out.insert(out.end(), rest.begin(), rest.end());
  return out;
}

// AOT backend for new features
void emit_match_expr(const MatchExpr& expr);
void emit_array_expr(const ArrayExpr& expr);
void emit_for_loop(const ForLoop& loop);
void emit_const_fn(const ConstFnDecl& fn);

// Generate switch for match
void emit_match_expr(const MatchExpr& expr) {
  // Generate if-else chain or switch
}

std::string emit_cpp(const Group& g, bool emit_main) {
  std::ostringstream o;

  o <<
R"(// AUTO-GENERATED by CAPS AOT backend
// Build example (MSVC):
//   cl /std:c++17 /O2 /EHsc generated.cpp
// Run:
//   generated.exe
#include <cstdint>
#include <string>
#include <iostream>
#include <utility>

)";

  // Result structs (typed, no variant)
  o <<
R"(struct Result_bool_text { bool ok; bool value; std::string error; };
struct Result_i64_text  { bool ok; int64_t value; std::string error; };
struct Result_text_text { bool ok; std::string value; std::string error; };

static inline Result_bool_text OkBool(bool v){ return {true, v, ""}; }
static inline Result_bool_text ErrBool(std::string e){ return {false, false, std::move(e)}; }

static inline Result_i64_text OkI64(int64_t v){ return {true, v, ""}; }
static inline Result_i64_text ErrI64(std::string e){ return {false, 0, std::move(e)}; }

static inline Result_text_text OkText(std::string v){ return {true, std::move(v), ""}; }
static inline Result_text_text ErrText(std::string e){ return {false, "", std::move(e)}; }

)";

  // Ring buffer + channels
  o <<
R"(template <typename T, uint32_t N>
struct Ring {
  static_assert(N > 0, "Ring size must be > 0");
  T buf[N];
  uint32_t head = 0;
  uint32_t tail = 0;
  uint32_t size = 0;

  bool push(const T& v) {
    if (size >= N) return false;
    buf[tail] = v;
    tail = (tail + 1) % N;
    size++;
    return true;
  }

  bool pop(T& out) {
    if (size == 0) return false;
    out = buf[head];
    head = (head + 1) % N;
    size--;
    return true;
  }
};

template <typename T, uint32_t N>
struct ChannelBuf {
  Ring<T, N> q;

  bool send(const T& v) { return q.push(v); }
  bool recv(T& out) { return q.pop(out); }

  Result_bool_text try_send(const T& v) {
    bool ok = q.push(v);
    return OkBool(ok);
  }

  // try_recv returns Result<T,text> specialized by T below via overloads.
};

)";

  // try_recv overloads per type
  o <<
R"(template <uint32_t N> static inline Result_i64_text try_recv_i64(ChannelBuf<int64_t,N>& c){
  int64_t v{};
  if (!c.recv(v)) return ErrI64("empty");
  return OkI64(v);
}
template <uint32_t N> static inline Result_bool_text try_recv_bool(ChannelBuf<bool,N>& c){
  bool v{};
  if (!c.recv(v)) return ErrBool("empty");
  return OkBool(v);
}
template <uint32_t N> static inline Result_text_text try_recv_text(ChannelBuf<std::string,N>& c){
  std::string v{};
  if (!c.recv(v)) return ErrText("empty");
  return OkText(std::move(v));
}

)";

  // Channels aggregate struct
  o << "struct Channels {\n";
  for (auto& ch : g.channels) {
    if (ch.capacity == 0) {
      // AOT ring-buffer channels require N>0.
      // If you want rendezvous channels, either:
      // - lower them to capacity=1 with explicit protocol, or
      // - emit a RendezvousChannel implementation.
      // For now: enforce >=1 in AOT.
      throw std::runtime_error("AOT emitter requires channel capacity >= 1 (ring buffer). Channel: " + ch.name);
    }
    o << "  ChannelBuf<" << cpp_type(ch.elem_type.kind) << ", " << ch.capacity << "> " << ident(ch.name) << ";\n";

    // attach try_recv method via wrapper lambdas in generated process code
  }
  o << "};\n\n";

  // Emit processes
  for (auto& p : g.processes) {
    std::string P = "Proc_" + ident(p.name);
    o << "struct " << P << " {\n";

    // locals
    for (auto& lv : p.locals) {
      o << "  " << cpp_type(lv.second.kind) << " " << ident(lv.first) << " {};\n";
    }

    // state enum
    o << "  enum class State {\n";
    auto ordered = topo_states(p);
    for (size_t i=0;i<ordered.size();i++) {
      o << "    " << ident(ordered[i]) << (i+1<ordered.size()? ",":"") << "\n";
    }
    o << "  };\n";

    o << "  State state = State::" << ident(p.initial_state) << ";\n";
    o << "  bool finished = false;\n\n";

    // step()
    o << "  void step(Channels& channels) {\n";
    o << "    if (finished) return;\n";
    o << "    bool blocked = false;\n";
    o << "    const char* block_reason = \"\";\n";
    o << "    switch (state) {\n";

    for (auto& sname : ordered) {
      auto it = p.states.find(sname);
      if (it == p.states.end()) throw std::runtime_error("missing state: " + sname);
      auto& st = it->second;

      o << "      case State::" << ident(st.name) << ": {\n";

      if (st.terminal) {
        o << "        finished = true;\n";
        o << "        return;\n";
      }

      // state actions
      emit_action_list(o, st.actions, g);

      // if blocked, return without transition
      o << "        if (blocked) return;\n";

      // transition
      if (st.tr.kind == Transition::Kind::Goto) {
        o << "        state = State::" << ident(st.tr.to_state) << ";\n";
        o << "        return;\n";
      } else {
        o << "        if (";
        emit_expr(o, st.tr.cond);
        o << ") {\n";
        emit_action_list(o, st.tr.then_actions, g);
        o << "          if (blocked) return;\n";
        o << "          state = State::" << ident(st.tr.then_state) << ";\n";
        o << "          return;\n";
        o << "        } else {\n";
        emit_action_list(o, st.tr.else_actions, g);
        o << "          if (blocked) return;\n";
        o << "          state = State::" << ident(st.tr.else_state) << ";\n";
        o << "          return;\n";
        o << "        }\n";
      }

      o << "      }\n";
    }

    o << "    }\n"; // switch
    o << "  }\n";   // step
    o << "};\n\n";
  }

  // Emit runner / main
  if (emit_main) {
    // schedule sanity: every step must match a process
    std::unordered_set<std::string> procset;
    for (auto& p : g.processes) procset.insert(p.name);

    for (auto& s : g.schedule) {
      if (!procset.count(s)) throw std::runtime_error("schedule references unknown process: " + s);
    }

    o << "int main() {\n";
    o << "  Channels channels;\n";

    // instantiate procs
    for (auto& p : g.processes) {
      o << "  Proc_" << ident(p.name) << " " << ident(p.name) << ";\n";
    }

    o << "  const uint64_t MAX_TICKS = 1000000;\n";
    o << "  for (uint64_t tick = 0; tick < MAX_TICKS; ++tick) {\n";
    o << "    bool any_progress = false;\n";

    // deterministic schedule: one step per process per tick (in given order)
    for (auto& step : g.schedule) {
      o << "    {\n";
      o << "      auto before_finished = " << ident(step) << ".finished;\n";
      o << "      auto before_state = " << ident(step) << ".state;\n";
      o << "      " << ident(step) << ".step(channels);\n";
      o << "      if (!before_finished || (before_state != " << ident(step) << ".state) || (" << ident(step) << ".finished != before_finished)) any_progress = true;\n";
      o << "    }\n";
    }

    // check complete
    o << "    bool all_finished = true;\n";
    for (auto& p : g.processes) {
      o << "    all_finished = all_finished && " << ident(p.name) << ".finished;\n";
    }
    o << "    if (all_finished) { std::cout << \"Completed\\n\"; return 0; }\n";

    // deadlock: no progress in a full tick
    o << "    if (!any_progress) { std::cerr << \"Deadlock\\n\"; return 2; }\n";
    o << "  }\n";
    o << "  std::cerr << \"MaxTicksExceeded\\n\";\n";
    o << "  return 2;\n";
    o << "}\n";
  }

  return o.str();
}

// AOT backend for enhanced channels, processes, timers, math, collections, I/O
void emit_enhanced_channel(const ChannelDecl& ch);
void emit_enhanced_process(const Process& p);
void emit_timer_functions();
void emit_math_functions();
void emit_collection_types();
void emit_io_functions();

// Enhanced channels: add priority queues, timeouts
void emit_enhanced_channel(const ChannelDecl& ch) {
  // Generate priority ring buffer or timeout logic
}

// Enhanced processes: add concurrency controls, better FSM
void emit_enhanced_process(const Process& p) {
  // Emit with enhanced state management
}

// Emit deterministic timer functions
void emit_timer_functions() {
  // get_deterministic_timer, set_timeout, etc.
}

// Emit static math utilities
void emit_math_functions() {
  // sin, cos, pow, gcd, etc.
}

// Emit fixed-size collections
void emit_collection_types() {
  // Arrays, stacks, queues
}

// Emit deterministic I/O
void emit_io_functions() {
  // read, write with bounds
}

// AOT backend enhancements for dead code elimination, channel fusion, process inlining,
// static memory layout, zero-copy message passing

std::string emit_cpp_optimized(const Group& g, bool emit_main) {
  // Apply optimizations before emitting
  Group optimized_g = optimize_group(g);

  // Emit optimized code
  return emit_cpp(optimized_g, emit_main);
}

// Optimize group
Group optimize_group(const Group& g) {
  Group opt = g;
  // Dead code elimination
  remove_unused_processes(opt);
  // Channel fusion
  fuse_channels(opt);
  // Process inlining
  inline_small_processes(opt);
  // Static memory layout
  layout_memory_statically(opt);
  // Zero-copy
  enable_zero_copy(opt);
  return opt;
}

// Helper functions
void remove_unused_processes(Group& g);
void fuse_channels(Group& g);
void inline_small_processes(Group& g);
void layout_memory_statically(Group& g);
void enable_zero_copy(Group& g);

} // namespace caps::aot
