This back end assumes your front end produces a lowered IR like:

IRProgram → groups

IRGroup → processes, channels, schedule

IRProcess → states → actions + transition (with then/else action lists)

Actions include Send/Receive/TrySend/TryReceive/Assign

Transitions include Goto and IfElse (with then/else actions lists)

It also implements your latest requirements:

Result + ? desugared to __Error state

Preserve error payload automatically

Auto-write __last_error:text on ? failure

Group-local channels are visible to processes (enforced earlier in sema; runtime uses resolved ids)

try_send / try_receive return Result<bool,text> / Result<T,text>

Deterministic blocking semantics, fixed schedule, deadlock detection

Trace format (tick + process-step + channel buffers)

--check-only is front end; backend provides clean exit signals (Completed, Deadlock)

*****

The ? desugaring contract (how backend expects it)

You asked:

? desugars to __Error

preserve error payload automatically

auto-write __last_error:text on ? failure

carry then/else action lists

✅ How to lower expr ? in your front end into this IR:

Given:

let x = safe_div(a,b) ?
do something_with x


Lower to:

Assign __tmp = safe_div(a,b) (pure call or precomputed)

In transition/branch actions:

If __tmp.ok == true: set x = __tmp.value

Else:

__last_error = __tmp.error (text)

__error_payload = __tmp or just error string (your choice)

transition to __Error

Because this backend already has:

__last_error created in locals for every process

Branch action lists executed before the transition target is applied

So your lowered IR transition becomes:

IfElse cond = (__tmp.ok)

then_actions: Assign x = Field(__tmp,"value")

else_actions: Assign __last_error = Field(__tmp,"error")

then_state = <normal next>

else_state = "__Error"

Then define:

state __Error
on __Error { -> __Error } // terminal or self-loop


Mark __Error as terminal if you want the process to end immediately.

How to wire this into your CLI (minimal)

Your CLI front end should:

parse + sema + lower → IRProgram

pick entry group by name (or first group)

init_runtime(rt, group)

TextTrace trace(std::cout) if you want logs

run_group(rt, &trace)

*****

AOT backend file tree
caps/
  src/
    aot/
      aot_ir_typed.h
      aot_codegen.h
      aot_codegen.cpp
      aot_toolchain.h
      aot_toolchain.cpp


You call it from your compiler driver like:

std::string cpp = caps::aot::emit_cpp(group_typed, /*emit_main=*/true);
caps::aot::compile_exe(cpp, "out.exe", /*optO2=*/true);

*****

How your front end should feed this AOT backend
1) Produce caps::aot::Group (typed IR)

From your existing sema/lowering, you likely already know:

var -> Type

expr -> Type

channel element types, capacities

state structure and transitions (with then/else action lists)

So just map your internal AST/IR into the typed structs.

2) Ensure ? is already lowered

Your AOT emitter does not implement ? directly. It expects the lowered pattern:

evaluate result into temp

branch: if ok then assign value else assign __last_error and goto __Error

__Error exists (terminal or loop)

3) For try_receive type

You must use the correct TypeKind:

try_receive channel<i64> returns Result_i64_text

try_receive channel<text> returns Result_text_text
etc.

Deterministic schedule loop semantics

The emitted main() does exactly:

For each tick:

Steps processes in group.schedule order

Each .step() executes one state’s actions + its transition

If an action blocks (channel full/empty), the process returns early and stays in same state

Terminates when:

all processes finished == true → exit 0

a full tick yields no progress → exit 2 (“Deadlock”)

max ticks exceeded → exit 2

That’s the “baked in deterministic schedule loop” you wanted.

*****

