module demo

@pipeline_safe
group Demo {
  channel<int; 1> c

  @max_sends(c, limit)
  process Producer(limit:int) -> () {
    state Start
    state Send
    state Done
    state __Error

    var current:int = 1

    on Start { -> Send }

    on Send {
      do send current -> c
      if current == limit {
        -> Done
      } else {
        do current = current + 1
        -> Send
      }
    }

    on Done { -> Done }

    on __Error { -> __Error }
  }

  @max_receives(c, count)
  process Consumer(count:int) -> (sum:int) {
    state Start
    state Receive
    state Finished
    state __Error

    var total:int = 0
    var received:int = 0

    on Start { -> Receive }

    on Receive {
      do rr = try_receive c
      do value:int = rr?
      do total = total + value
      do received = received + 1
      if received == count { -> Finished } else { -> Receive }
    }

    on Finished {
      do sum = total
      -> Finished
    }

    on __Error { -> __Error }
  }

  schedule {
    step Producer
    step Consumer
    repeat
  }
}
