#include "parser/parser.h"
#include <cstdlib>

Parser::Parser(Lexer& lx, Diag& d) : lex(lx), diag(d) {}

Token Parser::t() { return lex.peek(); }
Token Parser::eat() { Token a = lex.peek(); lex.consume(); return a; }
bool Parser::is(TokenKind k) { return t().kind == k; }
bool Parser::accept(TokenKind k) { if (is(k)) { eat(); return true; } return false; }

Token Parser::expect(TokenKind k, const char* msg) {
  if (!is(k)) { diag.error(t().pos, msg); return t(); }
  return eat();
}

Program Parser::parse_program() { return parse_program_inner(); }

std::vector<Annotation> Parser::parse_annotations() {
  std::vector<Annotation> anns;
  while (accept(TokenKind::At)) {
    Token nameTok = expect(TokenKind::Ident, "expected annotation name after '@'");
    Annotation a;
    a.name = nameTok.text;
    a.pos = nameTok.pos;
    if (accept(TokenKind::LParen)) {
      // parse raw args tokens until ')', splitting by commas
      std::string cur;
      while (!is(TokenKind::RParen) && !is(TokenKind::End)) {
        if (accept(TokenKind::Comma)) {
          if (!cur.empty()) { a.args.push_back(cur); cur.clear(); }
          continue;
        }
        Token tok = eat();
        if (!cur.empty()) cur.push_back(' ');
        cur += tok.text;
      }
      expect(TokenKind::RParen, "expected ')' to close annotation args");
      if (!cur.empty()) a.args.push_back(cur);
    }
    anns.push_back(std::move(a));
  }
  return anns;
}

ModuleDecl Parser::parse_module() {
  ModuleDecl m;
  Token kw = expect(TokenKind::KwModule, "expected 'module' at top of file");
  m.pos = kw.pos;
  Token id = expect(TokenKind::Ident, "expected module name");
  m.name = id.text;
  return m;
}

Program Parser::parse_program_inner() {
  Program p;
  p.module = parse_module();

  while (!is(TokenKind::End)) {
    auto anns = parse_annotations();
    if (is(TokenKind::KwGroup)) {
      GroupDecl g = parse_group();
      g.annotations.insert(g.annotations.begin(), anns.begin(), anns.end());
      p.groups.push_back(std::move(g));
      continue;
    }
    // For now: ignore other top-level decls (fn/type/import) in this frontend slice
    diag.error(t().pos, "unexpected top-level token (expected group)");
    eat();
  }
  return p;
}

int Parser::parse_int_literal_value(const Token& tok) {
  return std::atoi(tok.text.c_str());
}

TypeRef Parser::parse_type_ref() {
  // channel< T ; N > OR Ident OR primitives
  Token tok = eat();
  TypeRef tr;
  tr.name = tok.text;
  if (tok.kind == TokenKind::KwChannel) {
    // channel< T > or channel< T ; N >
    expect(TokenKind::Lt, "expected '<' after channel");
    TypeRef elem = parse_type_ref();
    int cap = 0;
    if (accept(TokenKind::Semi)) {
      Token n = expect(TokenKind::IntLit, "expected integer capacity after ';'");
      cap = parse_int_literal_value(n);
    }
    expect(TokenKind::Gt, "expected '>' after channel<...>");
    tr.is_channel = true;
    tr.name = "channel";
    tr.args = {elem};
    tr.channel_capacity = cap;
    return tr;
  }

  // generic type: Result<int,text>
  if (accept(TokenKind::Lt)) {
    while (!is(TokenKind::Gt) && !is(TokenKind::End)) {
      tr.args.push_back(parse_type_ref());
      if (!accept(TokenKind::Comma)) break;
    }
    expect(TokenKind::Gt, "expected '>' to close generic type args");
  }

  return tr;
}

Param Parser::parse_param() {
  Token id = expect(TokenKind::Ident, "expected parameter name");
  expect(TokenKind::Colon, "expected ':' after param name");
  TypeRef t = parse_type_ref();
  return Param{id.text, t, id.pos};
}

std::vector<Param> Parser::parse_param_list() {
  std::vector<Param> ps;
  if (is(TokenKind::RParen)) return ps;
  ps.push_back(parse_param());
  while (accept(TokenKind::Comma)) ps.push_back(parse_param());
  return ps;
}

ChannelDecl Parser::parse_channel_decl() {
  ChannelDecl c;
  Token kw = expect(TokenKind::KwChannel, "expected 'channel'");
  c.pos = kw.pos;
  // We already tokenized 'channel' as keyword; parse type as channel<...> form
  // Syntax: channel<int; 8> name
  expect(TokenKind::Lt, "expected '<' after channel");
  c.elem_type = parse_type_ref();
  int cap = 0;
  if (accept(TokenKind::Semi)) {
    Token n = expect(TokenKind::IntLit, "expected capacity integer");
    cap = parse_int_literal_value(n);
  }
  expect(TokenKind::Gt, "expected '>' after channel type");
  Token id = expect(TokenKind::Ident, "expected channel name");
  c.name = id.text;
  c.capacity = cap;
  return c;
}

GroupDecl Parser::parse_group() {
  GroupDecl g;
  Token kw = expect(TokenKind::KwGroup, "expected 'group'");
  g.pos = kw.pos;
  Token id = expect(TokenKind::Ident, "expected group name");
  g.name = id.text;
  expect(TokenKind::LBrace, "expected '{' after group name");

  while (!is(TokenKind::RBrace) && !is(TokenKind::End)) {
    auto anns = parse_annotations();

    if (is(TokenKind::KwChannel)) {
      ChannelDecl c = parse_channel_decl();
      g.channels.push_back(std::move(c));
      continue;
    }

    if (is(TokenKind::KwProcess)) {
      ProcessDecl p = parse_process();
      p.annotations.insert(p.annotations.begin(), anns.begin(), anns.end());
      g.processes.push_back(std::move(p));
      continue;
    }

    if (is(TokenKind::KwSchedule)) {
      g.schedule = parse_schedule();
      continue;
    }

    diag.error(t().pos, "unexpected token in group");
    eat();
  }

  expect(TokenKind::RBrace, "expected '}' to close group");
  return g;
}

ProcessDecl Parser::parse_process() {
  ProcessDecl p;
  Token kw = expect(TokenKind::KwProcess, "expected 'process'");
  p.pos = kw.pos;
  Token id = expect(TokenKind::Ident, "expected process name");
  p.name = id.text;

  expect(TokenKind::LParen, "expected '(' after process name");
  p.inputs = parse_param_list();
  expect(TokenKind::RParen, "expected ')' after input params");

  expect(TokenKind::Arrow, "expected '->' after process params");
  expect(TokenKind::LParen, "expected '(' before output params");
  p.outputs = parse_param_list();
  expect(TokenKind::RParen, "expected ')' after output params");

  expect(TokenKind::LBrace, "expected '{' to open process");

  while (!is(TokenKind::RBrace) && !is(TokenKind::End)) {
    if (accept(TokenKind::KwState)) {
      Token s = expect(TokenKind::Ident, "expected state name");
      p.states.push_back(s.text);
      continue;
    }

    if (is(TokenKind::KwLet) || is(TokenKind::KwVar)) {
      Stmt st = parse_stmt();
      p.locals.push_back(std::move(st));
      continue;
    }

    if (is(TokenKind::KwOn)) {
      p.on_blocks.push_back(parse_on_block());
      continue;
    }

    diag.error(t().pos, "unexpected token inside process");
    eat();
  }

  expect(TokenKind::RBrace, "expected '}' to close process");
  return p;
}

Stmt Parser::parse_stmt() {
  Stmt s;
  Token start = t();
  s.pos = start.pos;

  if (accept(TokenKind::KwLet)) {
    s.kind = Stmt::Kind::Let;
    Token name = expect(TokenKind::Ident, "expected name after let");
    s.name = name.text;
    if (accept(TokenKind::Colon)) {
      s.explicit_type = parse_type_ref();
    }
    expect(TokenKind::Assign, "expected '=' in let");
    s.expr = parse_expr();
    return s;
  }

  if (accept(TokenKind::KwVar)) {
    s.kind = Stmt::Kind::Var;
    Token name = expect(TokenKind::Ident, "expected name after var");
    s.name = name.text;
    if (accept(TokenKind::Colon)) {
      s.explicit_type = parse_type_ref();
    }
    expect(TokenKind::Assign, "expected '=' in var");
    s.expr = parse_expr();
    return s;
  }

  if (accept(TokenKind::KwReturn)) {
    s.kind = Stmt::Kind::Return;
    s.expr = parse_expr();
    return s;
  }

  // assignment: ident = expr
  if (is(TokenKind::Ident)) {
    Token name = eat();
    if (accept(TokenKind::Assign)) {
      s.kind = Stmt::Kind::Assign;
      s.name = name.text;
      s.expr = parse_expr();
      return s;
    }
    // fallback exprstmt starting with ident
    Expr e = Expr::ident(name.pos, name.text);
    s.kind = Stmt::Kind::ExprStmt;
    s.expr = e;
    return s;
  }

  s.kind = Stmt::Kind::ExprStmt;
  s.expr = parse_expr();
  return s;
}

Action Parser::parse_action() {
  Action a;
  a.pos = t().pos;

  if (accept(TokenKind::KwDo)) {
    a.kind = Action::Kind::DoStmt;
    a.stmt = parse_stmt();
    return a;
  }

  // send expr -> chan
  if (accept(TokenKind::KwSend)) {
    a.kind = Action::Kind::Send;
    a.send_expr = parse_expr();
    expect(TokenKind::Arrow, "expected '->' after send expr");
    Token c = expect(TokenKind::Ident, "expected channel name after '->'");
    a.chan = c.text;
    return a;
  }

  // receive chan -> x   OR receive chan -> var x:T
  if (accept(TokenKind::KwReceive)) {
    a.kind = Action::Kind::Receive;
    Token c = expect(TokenKind::Ident, "expected channel name after receive");
    a.chan = c.text;
    expect(TokenKind::Arrow, "expected '->' after channel");
    if (accept(TokenKind::KwVar)) {
      a.recv_declares = true;
      Token v = expect(TokenKind::Ident, "expected var name");
      a.recv_target = v.text;
      expect(TokenKind::Colon, "expected ':' after var name");
      a.recv_type = parse_type_ref();
    } else {
      Token v = expect(TokenKind::Ident, "expected receive target");
      a.recv_target = v.text;
    }
    return a;
  }

  // try_send expr -> chan -> outvar
  if (accept(TokenKind::KwTrySend)) {
    a.kind = Action::Kind::TrySend;
    a.try_send_expr = parse_expr();
    expect(TokenKind::Arrow, "expected '->' after try_send expr");
    Token c = expect(TokenKind::Ident, "expected channel name");
    a.try_send_chan = c.text;
    expect(TokenKind::Arrow, "expected second '->' to out var");
    Token out = expect(TokenKind::Ident, "expected out var name");
    a.try_send_outvar = out.text;
    return a;
  }

  // try_receive chan -> outvar
  if (accept(TokenKind::KwTryReceive)) {
    a.kind = Action::Kind::TryReceive;
    Token c = expect(TokenKind::Ident, "expected channel name");
    a.try_recv_chan = c.text;
    expect(TokenKind::Arrow, "expected '->' to out var");
    Token out = expect(TokenKind::Ident, "expected out var name");
    a.try_recv_outvar = out.text;
    return a;
  }

  diag.error(t().pos, "expected action (do/send/receive/try_send/try_receive)");
  eat();
  a.kind = Action::Kind::DoStmt;
  a.stmt.kind = Stmt::Kind::ExprStmt;
  a.stmt.pos = a.pos;
  a.stmt.expr = Expr::ident(a.pos, "__error__");
  return a;
}

Transition Parser::parse_transition() {
  Transition tr;
  tr.pos = t().pos;

  // Strong total rule: inside on-block we only accept:
  //   -> State
  //   if cond { actions } -> S else { actions } -> T
  if (accept(TokenKind::Arrow)) {
    tr.kind = Transition::Kind::Unconditional;
    Token st = expect(TokenKind::Ident, "expected state name after '->'");
    tr.to_state = st.text;
    return tr;
  }

  if (accept(TokenKind::KwIf)) {
    tr.kind = Transition::Kind::IfElse;
    tr.cond = parse_expr();

    // then block
    expect(TokenKind::LBrace, "expected '{' after if condition");
    while (!is(TokenKind::RBrace) && !is(TokenKind::End)) {
      tr.then_actions.push_back(parse_action());
    }
    expect(TokenKind::RBrace, "expected '}' to close if block");
    expect(TokenKind::Arrow, "expected '->' after if block");
    Token thenSt = expect(TokenKind::Ident, "expected then state name");
    tr.then_state = thenSt.text;

    // else required (strong)
    expect(TokenKind::KwElse, "missing else: total transition required");
    expect(TokenKind::LBrace, "expected '{' after else");
    while (!is(TokenKind::RBrace) && !is(TokenKind::End)) {
      tr.else_actions.push_back(parse_action());
    }
    expect(TokenKind::RBrace, "expected '}' to close else block");
    expect(TokenKind::Arrow, "expected '->' after else block");
    Token elseSt = expect(TokenKind::Ident, "expected else state name");
    tr.else_state = elseSt.text;

    return tr;
  }

  diag.error(t().pos, "expected transition ('-> State' or total 'if ... else ...')");
  tr.kind = Transition::Kind::Unconditional;
  tr.to_state = "__Error";
  return tr;
}

OnBlock Parser::parse_on_block() {
  OnBlock ob;
  Token kw = expect(TokenKind::KwOn, "expected 'on'");
  ob.pos = kw.pos;
  Token st = expect(TokenKind::Ident, "expected state name after on");
  ob.state_name = st.text;
  expect(TokenKind::LBrace, "expected '{' after on <State>");

  while (!is(TokenKind::RBrace) && !is(TokenKind::End)) {
    // transition must be last; we detect it by lookahead 'if' or '->'
    if (is(TokenKind::KwIf) || is(TokenKind::Arrow)) {
      ob.transition = parse_transition();
      break;
    }
    ob.actions.push_back(parse_action());
  }

  expect(TokenKind::RBrace, "expected '}' to close on-block");
  return ob;
}

ScheduleDecl Parser::parse_schedule() {
  ScheduleDecl s;
  Token kw = expect(TokenKind::KwSchedule, "expected 'schedule'");
  s.pos = kw.pos;
  expect(TokenKind::LBrace, "expected '{' after schedule");

  while (!is(TokenKind::RBrace) && !is(TokenKind::End)) {
    if (accept(TokenKind::KwStep)) {
      Token nm = expect(TokenKind::Ident, "expected process name after step");
      s.steps.push_back(nm.text);
      continue;
    }
    if (accept(TokenKind::KwRepeat)) {
      s.repeat = true;
      continue;
    }
    diag.error(t().pos, "unexpected token in schedule");
    eat();
  }

  expect(TokenKind::RBrace, "expected '}' to close schedule");
  return s;
}

// Pratt parsing
int Parser::infix_binding_power(TokenKind op, bool& right_assoc) const {
  right_assoc = false;
  switch (op) {
    case TokenKind::OrOr: return 1;
    case TokenKind::AndAnd: return 2;
    case TokenKind::EqEq:
    case TokenKind::NotEq: return 3;
    case TokenKind::Lt:
    case TokenKind::Lte:
    case TokenKind::Gt:
    case TokenKind::Gte: return 4;
    case TokenKind::Plus:
    case TokenKind::Minus: return 5;
    case TokenKind::Star:
    case TokenKind::Slash: return 6;
    default: return 0;
  }
}

Expr Parser::parse_primary() {
  Token tok = t();
  if (accept(TokenKind::Ident)) {
    Expr e = Expr::ident(tok.pos, tok.text);
    // call: ident(...)
    if (accept(TokenKind::LParen)) {
      Expr call;
      call.kind = Expr::Kind::Call;
      call.pos = tok.pos;
      call.args.push_back(e); // callee
      if (!is(TokenKind::RParen)) {
        call.args.push_back(parse_expr());
        while (accept(TokenKind::Comma)) call.args.push_back(parse_expr());
      }
      expect(TokenKind::RParen, "expected ')' after call");
      e = call;
    }
    // postfix '?'
    if (accept(TokenKind::Question)) {
      Expr te;
      te.kind = Expr::Kind::Try;
      te.pos = tok.pos;
      te.args.push_back(e);
      return te;
    }
    return e;
  }

  if (accept(TokenKind::IntLit)) {
    Expr e; e.kind=Expr::Kind::IntLit; e.pos=tok.pos; e.text=tok.text;
    if (accept(TokenKind::Question)) {
      diag.error(tok.pos, "postfix '?' requires Result<T,text>, not literal");
    }
    return e;
  }

  if (accept(TokenKind::RealLit)) {
    Expr e; e.kind=Expr::Kind::RealLit; e.pos=tok.pos; e.text=tok.text;
    return e;
  }

  if (accept(TokenKind::TextLit)) {
    Expr e; e.kind=Expr::Kind::TextLit; e.pos=tok.pos; e.text=tok.text;
    return e;
  }

  if (accept(TokenKind::LParen)) {
    Expr e = parse_expr();
    expect(TokenKind::RParen, "expected ')'");
    // postfix '?'
    if (accept(TokenKind::Question)) {
      Expr te; te.kind=Expr::Kind::Try; te.pos=e.pos; te.args.push_back(e);
      return te;
    }
    return e;
  }

  diag.error(tok.pos, "expected expression");
  eat();
  return Expr::ident(tok.pos, "__error__");
}

Expr Parser::parse_expr(int min_bp) {
  Expr lhs = parse_primary();

  while (true) {
    Token op = t();
    bool right_assoc = false;
    int bp = infix_binding_power(op.kind, right_assoc);
    if (bp < min_bp || bp == 0) break;
    eat();

    int next_bp = right_assoc ? bp : (bp + 1);
    Expr rhs = parse_expr(next_bp);

    Expr bin;
    bin.kind = Expr::Kind::Binary;
    bin.pos = op.pos;
    bin.text = op.text;
    bin.args = {lhs, rhs};
    lhs = bin;
  }

  // Postfix '?' already handled in primary for now
  return lhs;
}
